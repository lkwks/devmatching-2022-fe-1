# 프로그래머스 2022년 FE 데브매칭 상반기 과제 프로젝트 구현해보기


## 1. 개요

1) 키워드를 입력할 수 있는 입력창이 있다.

2) 입력받은 키워드를 API 서버에 전송하면 API 서버는 그 키워드와 스펠링이 일치하는 검색 결과를 리턴한다.

3) 검색 결과는 입력창 바로 밑에 나열돼야 한다.

4) 검색 결과 중 어느 하나를 클릭하거나, 키보드 위아래 화살표로 검색결과를 선택한 후 엔터키를 누르면 그 선택된 결과를 내용으로 하는 알림창이 브라우저에 떠야 한다.

5) 선택된 검색결과 히스토리가 입력창 위에 최대 5개까지 나열돼야 한다.

## 2. 구현 과정에서 어렵게 느낀 부분

1) 입력창에 마지막으로 글자를 찍은 후 1초 기다렸다가 API를 호출하는 식으로 구현했는데, '한 글자 찍은 후 1초 카운트다운 들어간 상태에서 다시 글자 입력을 했을 때 그전 카운트다운을 종료시키기'를 어떻게 구현할 것인지 난감했다.

  - 검색해보고 clearTimeout()의 개념을 알게 되었고, 금방 작동 원리에 익숙해져 간단히 구현할 수 있었다. (setTimeout() 함수가 리턴하는 값을 변수에 저장해뒀다가 키 입력 될 때마다 해당 변수를 clearTimeout()하면, 새 키워드 입력 후 이전 키워드에 대한 API 호출이 일어나는 것을 막을 수 있다.)


2) 검색결과 히스토리 부분의 경우 과거 선택된 것과 같은 것을 다시 선택했을 때 히스토리 앞쪽 엘리먼트를 지우고 뒤로 빼야 하는데, 진짜로 이런 식으로 노드를 remove 했다가 뒤에다 append 하는 게 나은지 고민됐다.

  - (1)제한시간이 굉장히 짧은 과제였는데 그런 식으로 구현하면 구현이 번거로워져 개발 일정이 크게 늘어날 수 있다고 생각했고, (2)무엇보다 전체적으로 엘리먼트를 create하거나 append하는 함수 호출은 각 클래스의 render()함수에 몰아서 하려고 했는데 그렇게 구현하면 엘리먼트의 create, append가 여기저기서 일어나 코딩하면서 헷갈릴 가능성이 높아질 수 있다고 생각했다. 그래서 for문으로 히스토리를 처음부터 끝까지 읽으면서 새 배열에 기존 히스토리 배열의 0번 인덱스를 제외한 그 이후 인덱스의 결과값을 하나씩 베껴넣는 식으로 히스토리를 갱신하고, 이런 갱신이 끝난 후 새 히스토리 배열을 기준으로 처음부터 다시 엘리먼트들을 render하는 식으로 구현했다.

  - 이러한 구현은 (1)새로운 배열을 만든다는 점에서 시공간의 낭비가 있고, (2)이미 만들어둔 엘리먼트를 모두 날리고 새 엘리먼트를 생성하는 데 추가로 시간이 든다는 점에서 여러모로 낭비라 볼 수 있다. 만약 이런 낭비의 리스크를 무시할 수 없는 문제라면 노드를 remove한 후 끝에 append하는 식의 구현을 하는 것이 나을 것 같다. (적어도 이 과제는 그런 리스크는 무시해도 되는 과제로 봐서 그냥 구현했다.)


## 3. 느낀점

- js의 구체적 함수 따위에 대한 지식이 부족해 구현에 시간이 아주 많이 걸렸으나, 구글링은 생각외로 그렇게 많이 하진 않았고 개발자 도구 콘솔창 새로고침을 굉장히 많이 사용했다. 전체적인 로직을 떠올리는 데는 큰 시간이 소요되지 않았고 별 어려움 없이 로직을 구성할 수 있었으나, 어떤 상황에서 무엇 때문에 에러가 나는지 예측하지 못한 상황이 너무 많았고 그 부분을 잡아내는 데 대부분의 시간이 소요됐다. (예를 들면, 엘리먼트 객체의 childNodes 멤버가 자식이 하나도 없을 때 값이 null이라고 굳게 믿어 에러가 발생했을 때 어디서 에러가 난 것인지를 발견하는 것 같은 부분에서 매우 많은 시간이 소요됐다.) 이런 부분에서 시간낭비를 줄이려면 상당한 시간의 개발 경험을 쌓을 것이 필요해 보인다.

- 내부적으로 사용할 변수명에 대해 미리 정해두거나 정리해둔 것 없이 필요할 때마다 떠오르는대로 적어가며 구현하다 보니, 제대로 작동하지 않는 원인이 무엇인지 한참 분석한 끝에 변수명이 불일치하기 때문이라는 걸 깨닫는다든가 하는 식의 시간낭비가 다소 있었다. 나름대로 개발 경험이 쌓여 변수명을 정하는 원칙이 뚜렷하게 생겼다고 생각했고, '그 원칙과 논리대로만 생각하면 과거 내가 정했던 변수명을 정확히 떠올릴 수 있다'라고 믿었으며, 실제로도 많은 변수명을 착오 없이 잘 코딩했으나, 결국 몇몇 부분에서 꽉 막혀 상당한 시간낭비가 발생했다. 원칙과 논리도 좋지만, 지나치게 맹신하기보다 이런 변수명 같은 것은 중요한 부분이므로 착오 없이 잘 정리해둘 필요가 있다는 걸 절실히 느꼈다.

- 전체적으로 앱이 로드됐을 때 가장 먼저 호출될 constructor에서부터 사소한 디테일까지 순서대로 구현했으며, 큰 기능 부분의 코드를 쓸 때 '이런 기능을 하는 함수를 호출한다'라는 코드를 쓴 후 실제 그 함수의 구현은 나중에 하는 식으로 구현했다. 이런 식의 하향식 코딩은 작년에 처음 시도해본 것인데 실제로 코딩할 때 복잡하고 다양한 기능을 가진 프로그램을 구현할 때 실제 코드 사이에는 스파게티처럼 무질서한 함수 호출이 일어나지 않을 수 있게 구현이 된 듯하고, 개발 속도도 생각보단 훨씬 빨랐던 것 같다. 자신감을 갖고 코딩하다 보면 다음에 비슷한 프로젝트를 할 때 훨씬 빠르고 적극적으로 구현에 참여할 수 있을 것 같다. 
